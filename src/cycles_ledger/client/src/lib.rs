//! Bindings to the cycles_depositor canister, generated by ./scripts/bind.sh
//!
//! Binding configuration: ./scripts/bind/rust/cycles_ledger.toml
//! 
//! Adapted from: https://github.com/dfinity/candid/blob/c2419ac6b7dfba4dd5e53f964b99bbdebc0308e2/rust/candid_parser/src/bindings/rust_stub.hbs#L4
#![allow(dead_code, unused_imports, clippy::all)]
use candid::{self, CandidType, Deserialize, Principal};


#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum ChangeIndexId { SetTo(Principal), Unset }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct UpgradeArgs {
  pub change_index_id: Option<ChangeIndexId>,
  pub max_blocks_per_request: Option<u64>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct InitArgs {
  pub index_id: Option<Principal>,
  pub max_blocks_per_request: u64,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum LedgerArgs { Upgrade(Option<UpgradeArgs>), Init(InitArgs) }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct SubnetFilter { pub subnet_type: Option<String> }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum SubnetSelection { Filter(SubnetFilter), Subnet{ subnet: Principal } }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct CanisterSettings {
  pub freezing_threshold: Option<candid::Nat>,
  pub controllers: Option<Vec<Principal>>,
  pub reserved_cycles_limit: Option<candid::Nat>,
  pub memory_allocation: Option<candid::Nat>,
  pub compute_allocation: Option<candid::Nat>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct CmcCreateCanisterArgs {
  pub subnet_selection: Option<SubnetSelection>,
  pub settings: Option<CanisterSettings>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct CreateCanisterArgs {
  pub from_subaccount: Option<serde_bytes::ByteBuf>,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
  pub creation_args: Option<CmcCreateCanisterArgs>,
}
pub type BlockIndex = candid::Nat;
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct CreateCanisterSuccess {
  pub block_id: BlockIndex,
  pub canister_id: Principal,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum CreateCanisterError {
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  Duplicate{ duplicate_of: candid::Nat, canister_id: Option<Principal> },
  CreatedInFuture{ ledger_time: u64 },
  FailedToCreate{
    error: String,
    refund_block: Option<BlockIndex>,
    fee_block: Option<BlockIndex>,
  },
  TooOld,
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct Account {
  pub owner: Principal,
  pub subaccount: Option<serde_bytes::ByteBuf>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct CreateCanisterFromArgs {
  pub spender_subaccount: Option<serde_bytes::ByteBuf>,
  pub from: Account,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
  pub creation_args: Option<CmcCreateCanisterArgs>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum RejectionCode {
  NoError,
  CanisterError,
  SysTransient,
  DestinationInvalid,
  Unknown,
  SysFatal,
  CanisterReject,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum CreateCanisterFromError {
  FailedToCreateFrom{
    create_from_block: Option<BlockIndex>,
    rejection_code: RejectionCode,
    refund_block: Option<BlockIndex>,
    approval_refund_block: Option<BlockIndex>,
    rejection_reason: String,
  },
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  InsufficientAllowance{ allowance: candid::Nat },
  Duplicate{ duplicate_of: candid::Nat, canister_id: Option<Principal> },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct DepositArgs {
  pub to: Account,
  pub memo: Option<serde_bytes::ByteBuf>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct DepositResult {
  pub balance: candid::Nat,
  pub block_index: BlockIndex,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct HttpRequest {
  pub url: String,
  pub method: String,
  pub body: serde_bytes::ByteBuf,
  pub headers: Vec<(String,String,)>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct HttpResponse {
  pub body: serde_bytes::ByteBuf,
  pub headers: Vec<(String,String,)>,
  pub status_code: u16,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum MetadataValue {
  Int(candid::Int),
  Nat(candid::Nat),
  Blob(serde_bytes::ByteBuf),
  Text(String),
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct SupportedStandard { pub url: String, pub name: String }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct TransferArgs {
  pub to: Account,
  pub fee: Option<candid::Nat>,
  pub memo: Option<serde_bytes::ByteBuf>,
  pub from_subaccount: Option<serde_bytes::ByteBuf>,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum TransferError {
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  BadBurn{ min_burn_amount: candid::Nat },
  Duplicate{ duplicate_of: candid::Nat },
  BadFee{ expected_fee: candid::Nat },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct AllowanceArgs { pub account: Account, pub spender: Account }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct Allowance { pub allowance: candid::Nat, pub expires_at: Option<u64> }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct ApproveArgs {
  pub fee: Option<candid::Nat>,
  pub memo: Option<serde_bytes::ByteBuf>,
  pub from_subaccount: Option<serde_bytes::ByteBuf>,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
  pub expected_allowance: Option<candid::Nat>,
  pub expires_at: Option<u64>,
  pub spender: Account,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum ApproveError {
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  Duplicate{ duplicate_of: candid::Nat },
  BadFee{ expected_fee: candid::Nat },
  AllowanceChanged{ current_allowance: candid::Nat },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  Expired{ ledger_time: u64 },
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct TransferFromArgs {
  pub to: Account,
  pub fee: Option<candid::Nat>,
  pub spender_subaccount: Option<serde_bytes::ByteBuf>,
  pub from: Account,
  pub memo: Option<serde_bytes::ByteBuf>,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum TransferFromError {
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  InsufficientAllowance{ allowance: candid::Nat },
  BadBurn{ min_burn_amount: candid::Nat },
  Duplicate{ duplicate_of: candid::Nat },
  BadFee{ expected_fee: candid::Nat },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetArchivesArgs { pub from: Option<Principal> }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetArchivesResultItem {
  pub end: candid::Nat,
  pub canister_id: Principal,
  pub start: candid::Nat,
}
pub type GetArchivesResult = Vec<GetArchivesResultItem>;
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetBlocksArgsItem { pub start: candid::Nat, pub length: candid::Nat }
pub type GetBlocksArgs = Vec<GetBlocksArgsItem>;
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum Value {
  Int(candid::Int),
  Map(Vec<(String,Box<Value>,)>),
  Nat(candid::Nat),
  Nat64(u64),
  Blob(serde_bytes::ByteBuf),
  Text(String),
  Array(Vec<Box<Value>>),
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetBlocksResultBlocksItem {
  pub id: candid::Nat,
  pub block: Box<Value>,
}
candid::define_function!(pub GetBlocksResultArchivedBlocksItemCallback : (
    GetBlocksArgs,
  ) -> (GetBlocksResult) query);
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetBlocksResultArchivedBlocksItem {
  pub args: GetBlocksArgs,
  pub callback: GetBlocksResultArchivedBlocksItemCallback,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetBlocksResult {
  pub log_length: candid::Nat,
  pub blocks: Vec<GetBlocksResultBlocksItem>,
  pub archived_blocks: Vec<GetBlocksResultArchivedBlocksItem>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct DataCertificate {
  pub certificate: serde_bytes::ByteBuf,
  pub hash_tree: serde_bytes::ByteBuf,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct SupportedBlockType { pub url: String, pub block_type: String }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct WithdrawArgs {
  pub to: Principal,
  pub from_subaccount: Option<serde_bytes::ByteBuf>,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum WithdrawError {
  FailedToWithdraw{
    rejection_code: RejectionCode,
    fee_block: Option<candid::Nat>,
    rejection_reason: String,
  },
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  Duplicate{ duplicate_of: candid::Nat },
  BadFee{ expected_fee: candid::Nat },
  InvalidReceiver{ receiver: Principal },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct WithdrawFromArgs {
  pub to: Principal,
  pub spender_subaccount: Option<serde_bytes::ByteBuf>,
  pub from: Account,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum WithdrawFromError {
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  InsufficientAllowance{ allowance: candid::Nat },
  Duplicate{ duplicate_of: BlockIndex },
  InvalidReceiver{ receiver: Principal },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  FailedToWithdrawFrom{
    withdraw_from_block: Option<candid::Nat>,
    rejection_code: RejectionCode,
    refund_block: Option<candid::Nat>,
    approval_refund_block: Option<candid::Nat>,
    rejection_reason: String,
  },
  InsufficientFunds{ balance: candid::Nat },
}


#[ic_cdk::init]
fn init(arg0: LedgerArgs) {
  unimplemented!()
}
#[ic_cdk::update]
fn create_canister(arg0: CreateCanisterArgs) -> std::result::Result<CreateCanisterSuccess, CreateCanisterError> {
  unimplemented!()
}
#[ic_cdk::update]
fn create_canister_from(arg0: CreateCanisterFromArgs) -> std::result::Result<CreateCanisterSuccess, CreateCanisterFromError> {
  unimplemented!()
}
#[ic_cdk::update]
fn deposit(arg0: DepositArgs) -> DepositResult {
  unimplemented!()
}
#[ic_cdk::query]
fn http_request(arg0: HttpRequest) -> HttpResponse {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_balance_of")]
fn icrc_1_balance_of(arg0: Account) -> candid::Nat {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_decimals")]
fn icrc_1_decimals() -> u8 {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_fee")]
fn icrc_1_fee() -> candid::Nat {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_metadata")]
fn icrc_1_metadata() -> Vec<(String,MetadataValue,)> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_minting_account")]
fn icrc_1_minting_account() -> Option<Account> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_name")]
fn icrc_1_name() -> String {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_supported_standards")]
fn icrc_1_supported_standards() -> Vec<SupportedStandard> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_symbol")]
fn icrc_1_symbol() -> String {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_total_supply")]
fn icrc_1_total_supply() -> candid::Nat {
  unimplemented!()
}
#[ic_cdk::update(name = "icrc1_transfer")]
fn icrc_1_transfer(arg0: TransferArgs) -> std::result::Result<BlockIndex, TransferError> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc2_allowance")]
fn icrc_2_allowance(arg0: AllowanceArgs) -> Allowance {
  unimplemented!()
}
#[ic_cdk::update(name = "icrc2_approve")]
fn icrc_2_approve(arg0: ApproveArgs) -> std::result::Result<candid::Nat, ApproveError> {
  unimplemented!()
}
#[ic_cdk::update(name = "icrc2_transfer_from")]
fn icrc_2_transfer_from(arg0: TransferFromArgs) -> std::result::Result<candid::Nat, TransferFromError> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc3_get_archives")]
fn icrc_3_get_archives(arg0: GetArchivesArgs) -> GetArchivesResult {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc3_get_blocks")]
fn icrc_3_get_blocks(arg0: GetBlocksArgs) -> GetBlocksResult {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc3_get_tip_certificate")]
fn icrc_3_get_tip_certificate() -> Option<DataCertificate> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc3_supported_block_types")]
fn icrc_3_supported_block_types() -> Vec<SupportedBlockType> {
  unimplemented!()
}
#[ic_cdk::update]
fn withdraw(arg0: WithdrawArgs) -> std::result::Result<BlockIndex, WithdrawError> {
  unimplemented!()
}
#[ic_cdk::update]
fn withdraw_from(arg0: WithdrawFromArgs) -> std::result::Result<BlockIndex, WithdrawFromError> {
  unimplemented!()
}

==========
// This is an experimental feature to generate Rust binding from Candid.
// You may want to manually adjust some of the types.
#![allow(dead_code, unused_imports)]
use candid::{self, CandidType, Deserialize, Principal};

#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum ChangeIndexId { SetTo(Principal), Unset }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct UpgradeArgs {
  pub change_index_id: Option<ChangeIndexId>,
  pub max_blocks_per_request: Option<u64>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct InitArgs {
  pub index_id: Option<Principal>,
  pub max_blocks_per_request: u64,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum LedgerArgs { Upgrade(Option<UpgradeArgs>), Init(InitArgs) }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct SubnetFilter { pub subnet_type: Option<String> }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum SubnetSelection { Filter(SubnetFilter), Subnet{ subnet: Principal } }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct CanisterSettings {
  pub freezing_threshold: Option<candid::Nat>,
  pub controllers: Option<Vec<Principal>>,
  pub reserved_cycles_limit: Option<candid::Nat>,
  pub memory_allocation: Option<candid::Nat>,
  pub compute_allocation: Option<candid::Nat>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct CmcCreateCanisterArgs {
  pub subnet_selection: Option<SubnetSelection>,
  pub settings: Option<CanisterSettings>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct CreateCanisterArgs {
  pub from_subaccount: Option<serde_bytes::ByteBuf>,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
  pub creation_args: Option<CmcCreateCanisterArgs>,
}
pub type BlockIndex = candid::Nat;
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct CreateCanisterSuccess {
  pub block_id: BlockIndex,
  pub canister_id: Principal,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum CreateCanisterError {
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  Duplicate{ duplicate_of: candid::Nat, canister_id: Option<Principal> },
  CreatedInFuture{ ledger_time: u64 },
  FailedToCreate{
    error: String,
    refund_block: Option<BlockIndex>,
    fee_block: Option<BlockIndex>,
  },
  TooOld,
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct Account {
  pub owner: Principal,
  pub subaccount: Option<serde_bytes::ByteBuf>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct CreateCanisterFromArgs {
  pub spender_subaccount: Option<serde_bytes::ByteBuf>,
  pub from: Account,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
  pub creation_args: Option<CmcCreateCanisterArgs>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum RejectionCode {
  NoError,
  CanisterError,
  SysTransient,
  DestinationInvalid,
  Unknown,
  SysFatal,
  CanisterReject,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum CreateCanisterFromError {
  FailedToCreateFrom{
    create_from_block: Option<BlockIndex>,
    rejection_code: RejectionCode,
    refund_block: Option<BlockIndex>,
    approval_refund_block: Option<BlockIndex>,
    rejection_reason: String,
  },
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  InsufficientAllowance{ allowance: candid::Nat },
  Duplicate{ duplicate_of: candid::Nat, canister_id: Option<Principal> },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct DepositArgs {
  pub to: Account,
  pub memo: Option<serde_bytes::ByteBuf>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct DepositResult {
  pub balance: candid::Nat,
  pub block_index: BlockIndex,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct HttpRequest {
  pub url: String,
  pub method: String,
  pub body: serde_bytes::ByteBuf,
  pub headers: Vec<(String,String,)>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct HttpResponse {
  pub body: serde_bytes::ByteBuf,
  pub headers: Vec<(String,String,)>,
  pub status_code: u16,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum MetadataValue {
  Int(candid::Int),
  Nat(candid::Nat),
  Blob(serde_bytes::ByteBuf),
  Text(String),
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct SupportedStandard { pub url: String, pub name: String }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct TransferArgs {
  pub to: Account,
  pub fee: Option<candid::Nat>,
  pub memo: Option<serde_bytes::ByteBuf>,
  pub from_subaccount: Option<serde_bytes::ByteBuf>,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum TransferError {
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  BadBurn{ min_burn_amount: candid::Nat },
  Duplicate{ duplicate_of: candid::Nat },
  BadFee{ expected_fee: candid::Nat },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct AllowanceArgs { pub account: Account, pub spender: Account }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct Allowance { pub allowance: candid::Nat, pub expires_at: Option<u64> }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct ApproveArgs {
  pub fee: Option<candid::Nat>,
  pub memo: Option<serde_bytes::ByteBuf>,
  pub from_subaccount: Option<serde_bytes::ByteBuf>,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
  pub expected_allowance: Option<candid::Nat>,
  pub expires_at: Option<u64>,
  pub spender: Account,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum ApproveError {
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  Duplicate{ duplicate_of: candid::Nat },
  BadFee{ expected_fee: candid::Nat },
  AllowanceChanged{ current_allowance: candid::Nat },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  Expired{ ledger_time: u64 },
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct TransferFromArgs {
  pub to: Account,
  pub fee: Option<candid::Nat>,
  pub spender_subaccount: Option<serde_bytes::ByteBuf>,
  pub from: Account,
  pub memo: Option<serde_bytes::ByteBuf>,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum TransferFromError {
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  InsufficientAllowance{ allowance: candid::Nat },
  BadBurn{ min_burn_amount: candid::Nat },
  Duplicate{ duplicate_of: candid::Nat },
  BadFee{ expected_fee: candid::Nat },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetArchivesArgs { pub from: Option<Principal> }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetArchivesResultItem {
  pub end: candid::Nat,
  pub canister_id: Principal,
  pub start: candid::Nat,
}
pub type GetArchivesResult = Vec<GetArchivesResultItem>;
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetBlocksArgsItem { pub start: candid::Nat, pub length: candid::Nat }
pub type GetBlocksArgs = Vec<GetBlocksArgsItem>;
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum Value {
  Int(candid::Int),
  Map(Vec<(String,Box<Value>,)>),
  Nat(candid::Nat),
  Nat64(u64),
  Blob(serde_bytes::ByteBuf),
  Text(String),
  Array(Vec<Box<Value>>),
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetBlocksResultBlocksItem {
  pub id: candid::Nat,
  pub block: Box<Value>,
}
candid::define_function!(pub GetBlocksResultArchivedBlocksItemCallback : (
    GetBlocksArgs,
  ) -> (GetBlocksResult) query);
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetBlocksResultArchivedBlocksItem {
  pub args: GetBlocksArgs,
  pub callback: GetBlocksResultArchivedBlocksItemCallback,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct GetBlocksResult {
  pub log_length: candid::Nat,
  pub blocks: Vec<GetBlocksResultBlocksItem>,
  pub archived_blocks: Vec<GetBlocksResultArchivedBlocksItem>,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct DataCertificate {
  pub certificate: serde_bytes::ByteBuf,
  pub hash_tree: serde_bytes::ByteBuf,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct SupportedBlockType { pub url: String, pub block_type: String }
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct WithdrawArgs {
  pub to: Principal,
  pub from_subaccount: Option<serde_bytes::ByteBuf>,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum WithdrawError {
  FailedToWithdraw{
    rejection_code: RejectionCode,
    fee_block: Option<candid::Nat>,
    rejection_reason: String,
  },
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  Duplicate{ duplicate_of: candid::Nat },
  BadFee{ expected_fee: candid::Nat },
  InvalidReceiver{ receiver: Principal },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  InsufficientFunds{ balance: candid::Nat },
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct WithdrawFromArgs {
  pub to: Principal,
  pub spender_subaccount: Option<serde_bytes::ByteBuf>,
  pub from: Account,
  pub created_at_time: Option<u64>,
  pub amount: candid::Nat,
}
#[derive(CandidType, Deserialize, Debug, Eq, PartialEq, Clone)]
pub enum WithdrawFromError {
  GenericError{ message: String, error_code: candid::Nat },
  TemporarilyUnavailable,
  InsufficientAllowance{ allowance: candid::Nat },
  Duplicate{ duplicate_of: BlockIndex },
  InvalidReceiver{ receiver: Principal },
  CreatedInFuture{ ledger_time: u64 },
  TooOld,
  FailedToWithdrawFrom{
    withdraw_from_block: Option<candid::Nat>,
    rejection_code: RejectionCode,
    refund_block: Option<candid::Nat>,
    approval_refund_block: Option<candid::Nat>,
    rejection_reason: String,
  },
  InsufficientFunds{ balance: candid::Nat },
}

#[ic_cdk::init]
fn init(arg0: LedgerArgs) {
  unimplemented!()
}
#[ic_cdk::update]
fn create_canister(arg0: CreateCanisterArgs) -> std::result::Result<CreateCanisterSuccess, CreateCanisterError> {
  unimplemented!()
}
#[ic_cdk::update]
fn create_canister_from(arg0: CreateCanisterFromArgs) -> std::result::Result<CreateCanisterSuccess, CreateCanisterFromError> {
  unimplemented!()
}
#[ic_cdk::update]
fn deposit(arg0: DepositArgs) -> DepositResult {
  unimplemented!()
}
#[ic_cdk::query]
fn http_request(arg0: HttpRequest) -> HttpResponse {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_balance_of")]
fn icrc_1_balance_of(arg0: Account) -> candid::Nat {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_decimals")]
fn icrc_1_decimals() -> u8 {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_fee")]
fn icrc_1_fee() -> candid::Nat {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_metadata")]
fn icrc_1_metadata() -> Vec<(String,MetadataValue,)> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_minting_account")]
fn icrc_1_minting_account() -> Option<Account> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_name")]
fn icrc_1_name() -> String {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_supported_standards")]
fn icrc_1_supported_standards() -> Vec<SupportedStandard> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_symbol")]
fn icrc_1_symbol() -> String {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc1_total_supply")]
fn icrc_1_total_supply() -> candid::Nat {
  unimplemented!()
}
#[ic_cdk::update(name = "icrc1_transfer")]
fn icrc_1_transfer(arg0: TransferArgs) -> std::result::Result<BlockIndex, TransferError> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc2_allowance")]
fn icrc_2_allowance(arg0: AllowanceArgs) -> Allowance {
  unimplemented!()
}
#[ic_cdk::update(name = "icrc2_approve")]
fn icrc_2_approve(arg0: ApproveArgs) -> std::result::Result<candid::Nat, ApproveError> {
  unimplemented!()
}
#[ic_cdk::update(name = "icrc2_transfer_from")]
fn icrc_2_transfer_from(arg0: TransferFromArgs) -> std::result::Result<candid::Nat, TransferFromError> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc3_get_archives")]
fn icrc_3_get_archives(arg0: GetArchivesArgs) -> GetArchivesResult {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc3_get_blocks")]
fn icrc_3_get_blocks(arg0: GetBlocksArgs) -> GetBlocksResult {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc3_get_tip_certificate")]
fn icrc_3_get_tip_certificate() -> Option<DataCertificate> {
  unimplemented!()
}
#[ic_cdk::query(name = "icrc3_supported_block_types")]
fn icrc_3_supported_block_types() -> Vec<SupportedBlockType> {
  unimplemented!()
}
#[ic_cdk::update]
fn withdraw(arg0: WithdrawArgs) -> std::result::Result<BlockIndex, WithdrawError> {
  unimplemented!()
}
#[ic_cdk::update]
fn withdraw_from(arg0: WithdrawFromArgs) -> std::result::Result<BlockIndex, WithdrawFromError> {
  unimplemented!()
}

