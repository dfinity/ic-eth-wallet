# airdrop

Welcome to your new airdrop project and to the internet computer development community. By default, creating a new project adds this README and some template files to your project directory. You can edit these template files to customize your project and to include your own code to speed up the development cycle.

To get started, you might want to explore the project directory structure and the default configuration file. Working with this project in your development environment will not affect any production deployment or identity tokens.

To learn more before you start working with airdrop, see the following documentation available online:

- [Quick Start](https://internetcomputer.org/docs/quickstart/quickstart-intro)
- [SDK Developer Tools](https://internetcomputer.org/docs/developers-guide/sdk-guide)
- [Rust Canister Devlopment Guide](https://internetcomputer.org/docs/rust-guide/rust-intro)
- [ic-cdk](https://docs.rs/ic-cdk)
- [ic-cdk-macros](https://docs.rs/ic-cdk-macros)
- [Candid Introduction](https://internetcomputer.org/docs/candid-guide/candid-intro)
- [JavaScript API Reference](https://erxue-5aaaa-aaaab-qaagq-cai.raw.icp0.io)

If you want to start working on your project right away, you might want to try the following commands:

```bash
cd airdrop/
dfx help
dfx canister --help
```

## Running the project locally

If you want to test your project locally, you can use the following commands:

```bash
# Starts the replica, running in the background
dfx start --background

# Deploys your canisters to the replica and generates your candid interface
dfx deploy
```

Once the job completes, your application will be available at `http://localhost:4943?canisterId={asset_canister_id}`.

If you have made changes to your backend canister, you can generate a new candid interface with

```bash
npm run generate
```

at any time. This is recommended before starting the frontend development server, and will be run automatically any time you run `dfx deploy`.

If you are making frontend changes, you can start a development server with

```bash
npm start
```

Which will start a server at `http://localhost:8080`, proxying API requests to the replica at port 4943.

### Note on frontend environment variables

If you are hosting frontend code somewhere without using DFX, you may need to make one of the following adjustments to ensure your project does not fetch the root key in production:

- set`DFX_NETWORK` to `production` if you are using Webpack
- use your own preferred method to replace `process.env.DFX_NETWORK` in the autogenerated declarations
  - Setting `canisters -> {asset_canister_id} -> declarations -> env_override to a string` in `dfx.json` will replace `process.env.DFX_NETWORK` with the string in the autogenerated declarations
- Write your own `createActor` constructor

# Airdrop

## Useful commands

```sh
dfx canister create --all

rustup target add wasm32-unknown-unknown

dfx canister install airdrop_backend

dfx canister call airdrop_backend generate_codes_seed '(123456, 5)'
dfx canister call airdrop_backend redeem_code '(record { ii = "ii"; code = "CODE-1"; eth_address = "eth_address" })'
dfx canister call airdrop_backend get_children_codes_for_ii '("ii")'
dfx canister call airdrop_backend get_eth_addresses_and_amounts

# check that we cannot redeem code more than once
dfx canister call airdrop_backend redeem_code '(record { ii = "ii"; code = "CODE-1"; eth_address = "eth_address" })'

# check we get the same children everytime
dfx canister call your_canister_name get_children_codes_for_ii '("ii")'

```

## Ethereum

you need to import metamask private keys into local geth in order to interact with the account

```bash
solc --bin --abi --optimize --overwrite -o ./build simplest-contract.sol

geth --goerli --unlock "56cc4915be0a7355045b25d989cfe5d1d2006461"

geth --goerli --syncmode "light" # connects us to the goerli network
geth --goerli --syncmode "light" --http --http.api "eth,net,web3,personal"
geth --goerli --syncmode "light" --ipcpath ~/Library/Ethereum/goerli/geth.ipc --http --http.api "eth,net,web3,personal"

geth --unlock 56cc4915be0a7355045b25d989cfe5d1d2006461 --password ./password

```

```
var abi = `cat build/SimpleStorage.abi | tr -d '\n'`;
var bin = `cat build/SimpleStorage.bin | tr -d '\n'`;


var simpleStorageContract = eth.contract(abi)

var gasEstimate = eth.estimateGas({data: bin});
console.log("Gas Estimate: " + gasEstimate);

var contractInstance = simpleStorageContract.new({from: eth.accounts[0], data: bin, gas: '47000'}, function(err, myContract){
  if(!err) {
     if(!myContract.address) {
         console.log("Transaction Hash:", myContract.transactionHash)
     } else {
         console.log("Contract Address:", myContract.address)
     }
  }
});

```

### Implement and deploy simplest contract first

### Re-implement part of the contract below and deploy it

https://github.com/benjizhai/ckicp-ethereum-contracts/blob/main/src/Airdrop.sol

## Gelato

Rate limiting - 5req/min

https://docs.gelato.network/developer-services/relay/non-erc-2771/sponsoredcall

## TODO

### Meeting

- do the protoype for the QR code generation that integrates with II
- gelato erc-20
- implement proper logging dashboard for us to track the event
- implement proper testing
- implement counter per person and total
- QR code on a colored background

- next week see proper setting up of the account
- I need principals from them to authorize the qr code generation

  - whitelist

- find out which cannister provides qr code as a service

- link up with Christian

### Cannister

- check for total depth and total amount of ii set-up
- [x] add hard kill
- [ ] implement batching from the cannister - we only use HTTP outcalls every X
- create two modes of qr code - direct ones requested from ipads / stands - and large one that we can display on the screen

  - for this we need to know how many people are there in the rooms when he will show it

- create simplest Ethereum contract
- set-up gelato account

- use http outcalls to send information to eth smart contract

- gasless / meta transactions service
  - gelato does not support sepolia
  - possible alternatives in case
    - https://docs.biconomy.io/docs/apireference/webhookapi
    - https://www.anydot.dev/
    - https://opengsn.org/

## Implementation

### David's call

useful commands

```bash
nmp deploy
npm ci
```

- first do the candid interface
- `npm run generate`

- redo the way we get the principal of the person
- we can implement a guard instead of calling check_if_killed()? everytime #[query(guard = "caller_is_admin_controller")]
- bundle up everything needed by frontend in as few fonctions as possible
- `redeem_code()`--> only if the url contains https://oisy.com?code=XXXX-XXX-XXX
- `get_code()` (instead of has_redeemed) --> called otherwise - returns the children code
- caller() -> to get the principal
- Result<Optional<Info>>
- None if hasn't redeemed or anything

```rust
struct Info {
  code: String,
  /// Option -- (Code, has_been_redeemed)
  children: Option<Vec<(String, bool)>>,
}
```

QR Code generator

- icp hubs - login
- authorize a few principals
- individually generate_code() -> seed will be generated from their principal
- ideally generate button
